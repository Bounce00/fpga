// (c) Copyright 2008 Xilinx, Inc. All rights reserved.
//
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
//
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
//
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
//
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// 

//
//  FRAME CHECK
//
//
//
//  Description: This module is a  pattern checker to test the Aurora
//               designs in hardware. The frames generated by FRAME_GEN
//               pass through the Aurora channel and arrive at the frame checker 
//               through the RX User interface. Every time an error is found in
//               the data recieved, the error count is incremented until it 
//               reaches its max value

`timescale 1 ns / 1 ps

module aurora_8b10b_v5_2_FRAME_CHECK
(
	input										USER_CLK			,       
	input										RESET				,
	input										CHANNEL_UP		,
	input										clk_25M			,
	input										PRI				,
(*keep = "true"*)	
	input				[63:0]				RX_D				,
(*keep = "true"*)	
	input				[ 2:0]				RX_REM			,   
(*keep = "true"*)		
	input										RX_SOF_N			,   
(*keep = "true"*)		
	input										RX_EOF_N			,
(*keep = "true"*)	
	input										RX_SRC_RDY_N	,
	output	reg	[35:0]				data_out						//接收数据输出

);

reg			[63:0]					rx_d_reg				;
reg										src_rdy_n_reg		;
reg										re_start				;
reg			[63:0]					comp_data			;
reg										rx_eof_n_reg		;
reg										rx_sof_n_reg		;
//--------------------fifo------------------------------
(*keep = "true"*)	
wire			[63:0]					fifo_dout			;
(*keep = "true"*)	
reg										rd_en					;
reg										wr_en					;
wire			[ 6:0]					rd_data_count		;
//-----------------------------------------------------
reg			[ 5:0]					cnt_data				;		//接收数据计数

always @(posedge USER_CLK or posedge RESET)
	if (RESET)
		rx_eof_n_reg				<=	1'b1					;
	else 
		rx_eof_n_reg				<= RX_EOF_N				;
		
always @(posedge USER_CLK or posedge RESET)
	if (RESET)
		rx_sof_n_reg				<=	1'b1					;
	else 
		rx_sof_n_reg				<=	RX_SOF_N				;
//------------------接收的数据----------------------
always @(posedge USER_CLK or posedge RESET)
	if (RESET)
		rx_d_reg						<=	64'h0					;
	else
		rx_d_reg						<=	RX_D					;

always @(posedge USER_CLK or posedge RESET)
	if (RESET)
		src_rdy_n_reg				<=	1'b1					;
	else
		src_rdy_n_reg				<=	RX_SRC_RDY_N		;
//------------------接收数据有效，写入fifo------------------
always @(posedge USER_CLK or posedge RESET)
	if (RESET)
		re_start						<=	1'b0					;
	else if (!rx_sof_n_reg)
		re_start						<=	1'b1					;
	else if (!rx_eof_n_reg)
		re_start						<=	1'b0					;
//------------------接收数据计数---------------------------
always @ ( posedge USER_CLK )
begin
	if(RESET)
		cnt_data						<=	6'd0					;
	else	if(!rx_sof_n_reg)
		cnt_data						<=	6'd1					;
	else	if(cnt_data==6'd32)
		cnt_data						<=	6'd0					;
	else	if(cnt_data>=1)
		cnt_data						<=	cnt_data+1			;
	else
		cnt_data						<=	cnt_data				;
end
//---------当cnt_data从1计数到32时，fifo写使能--------------
always @ ( posedge USER_CLK )
begin
	if(RESET)
		wr_en							<=	1'b0					;
	else	if(!rx_sof_n_reg)
		wr_en							<=	1'b1					;
	else	if(cnt_data==6'd32)
		wr_en							<=	1'b0					;
	else
		wr_en							<=	wr_en					;
end
		
aurora_fifo inst_aurora (
		.rst							(PRI					), 			// input rst
		.wr_clk						(USER_CLK			), 			// input wr_clk
		.rd_clk						(clk_25M				), 			// input rd_clk
		.din							(rx_d_reg			), 			// input [63 : 0] din
		.wr_en						(wr_en				), 			// input wr_en
		.rd_en						(rd_en				), 			// input rd_en
		.dout							(fifo_dout			), 			// output [63 : 0] dout
		.full							(full					), 			// output full
		.empty						(empty				), 			// output empty
		.rd_data_count				(rd_data_count		) 				// output [7 : 0] rd_data_count
);

always @ ( posedge clk_25M )
begin
	if(RESET)
		rd_en							<=	1'b0					;
	else	if(rd_data_count==7'd32)
		rd_en							<=	1'b1					;
	else	
		rd_en							<=	rd_en					;
end
		
		
endmodule           
